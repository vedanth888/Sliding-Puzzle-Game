<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Puzzle Game</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for smooth transitions and aesthetics */
        body {
            font-family: 'Inter', sans-serif;
        }
        .tile {
            transition: top 0.2s ease-in-out, left 0.2s ease-in-out;
            touch-action: none; /* Prevents scrolling on touch devices */
        }
        /* Win celebration particle animation */
        @keyframes confetti-fall {
            0% { transform: translateY(-10vh) rotateZ(0deg); opacity: 1; }
            100% { transform: translateY(110vh) rotateZ(360deg); opacity: 0; }
        }
        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            pointer-events: none;
            animation: confetti-fall 3s linear infinite;
        }
    </style>
    <!-- Google Fonts for better typography -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="min-h-screen bg-gradient-to-br from-purple-50 to-blue-100 flex flex-col items-center justify-center p-4 overflow-hidden relative">
    
    <!-- Container for dynamic background shapes -->
    <div id="background-shapes" class="absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none"></div>
    
    <!-- Win celebration particle container -->
    <div id="particle-container" class="absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none"></div>

    <main class="z-10 flex flex-col items-center">
        <h1 class="text-5xl font-bold text-gray-800 mb-2">Sliding Puzzle</h1>
        <p class="text-gray-600 mb-6 text-lg">Arrange the tiles in numerical order</p>

        <!-- Game statistics panel -->
        <div class="flex justify-between w-full max-w-sm mb-6 bg-white/80 backdrop-blur-sm p-4 rounded-xl shadow-lg">
            <div class="text-center">
                <p class="text-sm text-gray-600">Moves</p>
                <p id="moves-count" class="text-2xl font-bold text-gray-800">0</p>
            </div>
            <div class="text-center">
                <p class="text-sm text-gray-600">Time</p>
                <p id="timer" class="text-2xl font-bold text-gray-800">00:00</p>
            </div>
            <div class="text-center">
                <p class="text-sm text-gray-600">Size</p>
                <select id="grid-size-selector" class="text-lg font-bold text-gray-800 bg-transparent border-none focus:ring-0 appearance-none">
                    <option value="3">3x3</option>
                    <option value="4" selected>4x4</option>
                    <option value="5">5x5</option>
                </select>
            </div>
        </div>

        <!-- The game board where tiles will be rendered -->
        <div id="game-board" class="relative bg-white/90 backdrop-blur-md rounded-2xl shadow-2xl p-2 mb-6 border-2 border-white/30" style="width: 300px; height: 300px;">
             <!-- Tiles are generated by JavaScript -->
        </div>

        <!-- Win message (initially hidden) -->
        <div id="win-message" class="hidden bg-gradient-to-r from-green-400 to-teal-500 text-white px-6 py-4 rounded-xl mb-6 text-center shadow-lg">
            <p class="font-bold text-2xl mb-2">Congratulations!</p>
            <p id="win-details"></p>
        </div>

        <!-- Controls for the game -->
        <div class="flex flex-col items-center gap-4 w-full max-w-sm">
            <div id="touch-controls-container" class="w-full hidden">
                <!-- On-screen controls for touch devices will be generated here -->
            </div>
            <p id="keyboard-hint" class="text-gray-600 text-sm mb-2">Use WASD or Arrow Keys to move tiles</p>
            
            <div class="flex gap-4">
                <button id="restart-button" class="bg-gradient-to-r from-blue-500 to-indigo-600 text-white px-6 py-3 rounded-lg font-medium shadow-lg hover:shadow-xl active:scale-95 transition-transform">
                    New Game
                </button>
            </div>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Element References ---
            const gameBoard = document.getElementById('game-board');
            const movesCountEl = document.getElementById('moves-count');
            const timerEl = document.getElementById('timer');
            const gridSizeSelector = document.getElementById('grid-size-selector');
            const restartButton = document.getElementById('restart-button');
            const winMessageEl = document.getElementById('win-message');
            const winDetailsEl = document.getElementById('win-details');
            const particleContainer = document.getElementById('particle-container');
            const backgroundShapesContainer = document.getElementById('background-shapes');

            // --- Game State Variables ---
            let gridSize = 4;
            let tiles = [];
            let emptyIndex = -1;
            let moves = 0;
            let time = 0;
            let timerInterval = null;
            let gameWon = false;

            // --- Game Logic ---

            /**
             * Initializes the game state, shuffles the tiles, and starts a new game.
             */
            function initializeGame() {
                gridSize = parseInt(gridSizeSelector.value);
                const totalTiles = gridSize * gridSize;
                
                // Reset state
                gameWon = false;
                moves = 0;
                time = 0;
                clearInterval(timerInterval);
                winMessageEl.classList.add('hidden');
                particleContainer.innerHTML = '';
                
                // Create ordered tiles array
                tiles = Array.from({ length: totalTiles - 1 }, (_, i) => i + 1);
                tiles.push(0); // 0 represents the empty tile
                
                // Shuffle the tiles until it's a solvable configuration
                shuffleTiles();
                while (!isSolvable()) {
                    shuffleTiles();
                }

                emptyIndex = tiles.indexOf(0);
                
                renderBoard();
                updateStats();
                startTimer();
            }

            /**
             * Shuffles the tiles array using the Fisher-Yates algorithm.
             */
            function shuffleTiles() {
                for (let i = tiles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
                }
            }

            /**
             * Checks if the shuffled puzzle is solvable.
             * This prevents impossible game states.
             */
            function isSolvable() {
                let inversions = 0;
                for (let i = 0; i < tiles.length - 1; i++) {
                    for (let j = i + 1; j < tiles.length; j++) {
                        if (tiles[i] && tiles[j] && tiles[i] > tiles[j]) {
                            inversions++;
                        }
                    }
                }
                
                if (gridSize % 2 === 1) { // Odd grid
                    return inversions % 2 === 0;
                } else { // Even grid
                    const emptyRowFromBottom = gridSize - Math.floor(tiles.indexOf(0) / gridSize);
                    return (inversions + emptyRowFromBottom) % 2 === 0;
                }
            }

            /**
             * Renders the game board and tiles based on the current state.
             */
            function renderBoard() {
                gameBoard.innerHTML = '';
                const boardSize = Math.min(window.innerWidth * 0.8, 400); // Responsive board size
                gameBoard.style.width = `${boardSize}px`;
                gameBoard.style.height = `${boardSize}px`;

                tiles.forEach((tileValue, index) => {
                    if (tileValue === 0) return; // Don't render the empty space

                    const tileEl = document.createElement('div');
                    tileEl.textContent = tileValue;
                    tileEl.className = 'tile absolute flex items-center justify-center text-xl font-bold rounded-xl cursor-pointer shadow-md text-white select-none';
                    
                    const tileSize = `calc(100% / ${gridSize} - 4px)`;
                    const position = `calc(${(100 / gridSize)}%)`;
                    
                    tileEl.style.width = tileSize;
                    tileEl.style.height = tileSize;
                    tileEl.style.left = `calc(${(index % gridSize)} * ${position} + 2px)`;
                    tileEl.style.top = `calc(${Math.floor(index / gridSize)} * ${position} + 2px)`;
                    
                    const hue = (tileValue * 25) % 360;
                    tileEl.style.backgroundColor = `hsl(${hue}, 70%, 60%)`;

                    tileEl.addEventListener('click', () => moveTile(index));
                    gameBoard.appendChild(tileEl);
                });
            }

            /**
             * Moves a tile to the empty space if the move is valid.
             * @param {number} tileIndex - The index of the tile to move.
             */
            function moveTile(tileIndex) {
                if (gameWon) return;

                const tileRow = Math.floor(tileIndex / gridSize);
                const tileCol = tileIndex % gridSize;
                const emptyRow = Math.floor(emptyIndex / gridSize);
                const emptyCol = emptyIndex % gridSize;

                // Check if the tile is adjacent to the empty space
                const isAdjacent = (Math.abs(tileRow - emptyRow) === 1 && tileCol === emptyCol) ||
                                   (Math.abs(tileCol - emptyCol) === 1 && tileRow === emptyRow);
                
                if (isAdjacent) {
                    // Swap tiles in the state array
                    [tiles[tileIndex], tiles[emptyIndex]] = [tiles[emptyIndex], tiles[tileIndex]];
                    emptyIndex = tileIndex;
                    moves++;
                    
                    renderBoard();
                    updateStats();
                    checkWinCondition();
                }
            }

            /**
             * Checks if the puzzle is solved.
             */
            function checkWinCondition() {
                for (let i = 0; i < tiles.length - 1; i++) {
                    if (tiles[i] !== i + 1) return;
                }

                if (tiles[tiles.length - 1] === 0) {
                    gameWon = true;
                    clearInterval(timerInterval);
                    winDetailsEl.textContent = `You solved the ${gridSize}x${gridSize} puzzle in ${moves} moves and ${formatTime(time)}.`;
                    winMessageEl.classList.remove('hidden');
                    createWinParticles();
                }
            }

            /**
             * Updates the moves and time display.
             */
            function updateStats() {
                movesCountEl.textContent = moves;
                timerEl.textContent = formatTime(time);
            }

            /**
             * Starts the game timer.
             */
            function startTimer() {
                timerInterval = setInterval(() => {
                    time++;
                    updateStats();
                }, 1000);
            }

            /**
             * Formats seconds into MM:SS format.
             * @param {number} seconds - The time in seconds.
             * @returns {string} The formatted time string.
             */
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }

            /**
             * Creates confetti-like particles for the win celebration.
             */
            function createWinParticles() {
                for (let i = 0; i < 50; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    const hue = Math.random() * 360;
                    particle.style.backgroundColor = `hsl(${hue}, 90%, 60%)`;
                    particle.style.left = `${Math.random() * 100}vw`;
                    particle.style.animationDelay = `${Math.random() * 3}s`;
                    particleContainer.appendChild(particle);
                }
            }
            
            /**
             * Creates animated background shapes.
             */
            function createBackgroundShapes() {
                for (let i = 0; i < 5; i++) {
                    const shape = document.createElement('div');
                    const size = Math.random() * 100 + 50;
                    shape.className = 'absolute rounded-full bg-purple-200 opacity-20';
                    shape.style.width = `${size}px`;
                    shape.style.height = `${size}px`;
                    shape.style.top = `${Math.random() * 100}%`;
                    shape.style.left = `${Math.random() * 100}%`;
                    shape.style.transition = `transform ${Math.random() * 10 + 10}s ease-in-out alternate`;
                    backgroundShapesContainer.appendChild(shape);

                    // Animate the shapes randomly
                    setInterval(() => {
                        const x = Math.random() * 30 - 15;
                        const y = Math.random() * 30 - 15;
                        shape.style.transform = `translate(${x}px, ${y}px)`;
                    }, Math.random() * 5000 + 5000);
                }
            }

            // --- Event Listeners ---
            restartButton.addEventListener('click', initializeGame);
            gridSizeSelector.addEventListener('change', initializeGame);
            
            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                let targetIndex = -1;
                const row = Math.floor(emptyIndex / gridSize);
                const col = emptyIndex % gridSize;

                switch (e.key) {
                    case 'ArrowUp': case 'w': if (row < gridSize - 1) targetIndex = emptyIndex + gridSize; break;
                    case 'ArrowDown': case 's': if (row > 0) targetIndex = emptyIndex - gridSize; break;
                    case 'ArrowLeft': case 'a': if (col < gridSize - 1) targetIndex = emptyIndex + 1; break;
                    case 'ArrowRight': case 'd': if (col > 0) targetIndex = emptyIndex - 1; break;
                }
                
                if (targetIndex !== -1) {
                    e.preventDefault(); // Prevent page scrolling
                    moveTile(targetIndex);
                }
            });

            // Detect touch device and show controls if needed
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                document.getElementById('keyboard-hint').classList.add('hidden');
                document.getElementById('touch-controls-container').classList.remove('hidden');
                // Simple touch control hints for now, as on-screen d-pads can be complex.
                document.getElementById('touch-controls-container').innerHTML = `
                    <p class="text-gray-600 text-sm">Click tiles to move them.</p>
                `;
            }

            // --- Initial Setup ---
            createBackgroundShapes();
            initializeGame();
            window.addEventListener('resize', renderBoard); // Re-render on resize for responsiveness
        });
    </script>
</body>
</html>
